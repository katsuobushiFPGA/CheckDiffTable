# トランザクション差分チェック・更新システム要件書

## 1. 概要

本システムは、大量のトランザクションデータが流入するトランザクションテーブルから最新データのみを保持する専用テーブルに対して、効率的な一括処理で差分チェックを行い必要に応じて更新を行うシステムです。

## 2. 要件

### 2.1 基本要件

1. **トランザクションテーブル**
   - 大量のトランザクションデータが継続的に流入する
   - 各エンティティの複数の状態変更履歴を保持
   - 処理毎にテーブルがトランケートされる前提

2. **最新データテーブル**
   - 各エンティティの最新状態のみを保持する
   - 常に最新状態のデータのみを保持する

3. **効率的な一括処理**
   - エンティティ毎の最新トランザクションを一括取得
   - 関連する最新データを一括取得
   - 差分チェック後、一括でUPSERT処理

4. **差分比較機能**
   - 既存データと新しいデータを比較し、差分の有無を判定する
   - 差分がない場合は更新処理をスキップする

5. **データ更新ロジック**
   - データが存在しない場合：新規登録
   - データが存在し、差分がある場合：更新
   - データが存在し、差分がない場合：処理なし

### 2.2 技術要件

- **言語**: C#
- **データベースライブラリ**: Npgsql (PostgreSQL)
- **データベース**: PostgreSQL

## 3. システム解釈・設計

### 3.1 テーブル設計

#### 3.1.1 トランザクションテーブル（transaction_table）
```sql
-- 大量のトランザクションデータが入ってくるテーブル
CREATE TABLE transaction_table (
    id SERIAL PRIMARY KEY,
    entity_id INTEGER NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL,
    amount DECIMAL(10,2),
    transaction_type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.1.2 最新データテーブル（latest_data_table）
```sql
-- 最新の1件のみを保持するテーブル
CREATE TABLE latest_data_table (
    entity_id INTEGER PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    status VARCHAR(20) NOT NULL,
    amount DECIMAL(10,2),
    transaction_type VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 3.2 効率化された処理フロー

1. **最新トランザクション一括取得**
   - WITH句を使用してエンティティごとの最新トランザクションのみを効率的に取得

2. **関連最新データ一括取得**
   - ANY演算子を使用して関連するエンティティの最新データを一括取得

3. **メモリ内差分チェック**
   - 取得したデータをメモリ内で差分チェック
   - データベースアクセス回数を最小化

4. **一括UPSERT処理**
   - PostgreSQLのON CONFLICT構文を使用した効率的な一括UPSERT

### 3.3 実装方針

1. **データアクセス層**
   - Repository パターンを使用
   - 一括処理用メソッドを提供
   - Npgsqlを使用したデータベース接続

2. **ビジネスロジック層**
   - 一括処理サービス（BatchProcessAllEntitiesAsync）
   - 個別処理サービス（ProcessEntityAsync）
   - 差分チェックロジック

3. **モデル**
   - TransactionEntity（トランザクションエンティティ）
   - LatestDataEntity（最新データエンティティ）
   - BatchProcessResult（一括処理結果）

## 4. 期待される動作

### 4.1 シナリオ1: 初回データ登録（一括処理）
- 条件：latest_data_tableが空、transaction_tableに未処理データ多数
- 結果：全エンティティを一括INSERT

### 4.2 シナリオ2: 混在データ更新（一括処理）
- 条件：一部エンティティは既存データあり、一部は新規
- 結果：差分ありは一括UPDATE、新規は一括INSERT、差分なしはスキップ

### 4.3 シナリオ3: 大量トランザクション処理
- 条件：数千〜数万件のトランザクションが未処理
- 結果：効率的な一括処理で高速処理

## 5. パフォーマンス最適化

### 5.1 データベース最適化
- **インデックス戦略**
  - エンティティID + 作成日時の降順インデックス

- **クエリ最適化**
  - WITH句による効率的なサブクエリ
  - ANY演算子による一括条件指定
  - UPSERT構文による一括更新

### 5.2 アプリケーション最適化
- **メモリ効率**
  - 必要最小限のデータ取得
  - ストリーミング処理対応可能

- **処理効率**
  - データベースアクセス回数最小化
  - 一括処理によるネットワーク負荷軽減

## 6. 運用考慮事項

### 6.1 処理モード
- **一括処理モード（推奨）**: 最高効率での全件処理
- **個別処理モード**: デバッグ・特定エンティティ処理用

### 6.2 監視・ログ
- 処理時間の測定・ログ出力
- 処理件数のサマリー出力
- エラー詳細ログ

### 6.3 エラーハンドリング
- トランザクション単位のエラー分離
- 部分的失敗時の継続処理
- 詳細なエラー報告
